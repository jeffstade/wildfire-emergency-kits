#libraries
```{r setup}
library(sf)
library(tidycensus)
library(tidyverse)
library(dplyr)
library(grid)
library(gridExtra)
library(ggplot2)
palette5 <- c("#f0f9e8","#bae4bc","#7bccc4","#43a2ca","#0868ac")
projection <- "EPSG:6423"
options(scipen = 999)
```

# Asssessing population vulnerability

Our final algorithm for allocating emergency supply kits will not only take into account the probability of a fire occurring. We will also prioritize census tracts to receive aid if their populations are more "vulnerable" to an emergency like a wildfire. These populations may be less likely to be able to evacuate or less likely to be able to purchase/own an emergency supply kit on their own.

We initially explored creating our own composite score, but decided to use the reputable CDC Social Vulnerability Index (https://www.atsdr.cdc.gov/placeandhealth/svi/index.html). The SVI uses variables from the American Community Survey. Among its many uses, CDC recommends using the score to "allocate emergency preparedness funding by community need."

```{r getVulnIndexScore}
vulnIndex <- st_read("California-SVI/SVI2018_CALIFORNIA_tract.shp") %>%
  filter(COUNTY == 'Los Angeles') %>%
  filter(FIPS != '06037599100') %>%
  filter(FIPS != '06037599000') %>%
  dplyr::select(starts_with("RPL_"),"COUNTY","FIPS","LOCATION","E_TOTPOP") %>%
  mutate_if(is.numeric, list(~na_if(., -999)))  %>%
  st_transform(projection) 
```

The Social Vulnerability Index is made up of 4 sub-themes: 


![Social vulnerability index]("https://www.atsdr.cdc.gov/placeandhealth/svi/documentation/pdf/Documentation_Image.jpg")
**Image from CDC**

We fetched the data for each of these themes for each census tract in Los Angeles County. These plots show the tracts' percentile rankings for of the sub-themes as well as the primary composite score.

```{r exploratoryPlots}
svi_theme1 <- ggplot(vulnIndex) +
  geom_sf(data = st_union(vulnIndex))+
  geom_sf(aes(fill = q5(RPL_THEME1)),lwd = 0) +
  scale_fill_manual(values = palette5,
                    labels = qBr(vulnIndex %>% drop_na(RPL_THEME1), "RPL_THEME1", rnd=FALSE),
                    name = "Percentile") +
  labs(title = "Socioeconomic status", subtitle = "By census tract, 2018 CDC Social Vulnerability Index") +
  mapTheme() + 
  theme(plot.title = element_text(size=16))

svi_theme2 <- ggplot(vulnIndex) +
  geom_sf(data = st_union(vulnIndex))+
  geom_sf(aes(fill = q5(RPL_THEME2)),lwd = 0) +
  scale_fill_manual(values = palette5,
                    labels = qBr(vulnIndex %>% drop_na(RPL_THEME2), "RPL_THEME2", rnd=FALSE),
                    name = "Percentile") +
  labs(title = "Household composition & disability", subtitle = "By census tract, 2018 CDC Social Vulnerability Index") +
  mapTheme() + 
  theme(plot.title = element_text(size=16))

svi_theme3 <- ggplot(vulnIndex) +
  geom_sf(data = st_union(vulnIndex))+
  geom_sf(aes(fill = q5(RPL_THEME3)),lwd = 0) +
  scale_fill_manual(values = palette5,
                    labels = qBr(vulnIndex %>% drop_na(RPL_THEME3), "RPL_THEME3", rnd=FALSE),
                    name = "Percentile") +
  labs(title = "Minority status & language", subtitle = "By census tract, 2018 CDC Social Vulnerability Index") +
  mapTheme() + 
  theme(plot.title = element_text(size=16))

svi_theme4 <- ggplot(vulnIndex) +
  geom_sf(data = st_union(vulnIndex))+
  geom_sf(aes(fill = q5(RPL_THEME4)),lwd = 0) +
  scale_fill_manual(values = palette5,
                    labels = qBr(vulnIndex %>% drop_na(RPL_THEME4), "RPL_THEME4", rnd=FALSE),
                    name = "Percentile") +
  labs(title = "Housing type & transportation", subtitle = "By census tract, 2018 CDC Social Vulnerability Index") +
  mapTheme() + 
  theme(plot.title = element_text(size=16))

grid.arrange(svi_theme1, svi_theme2, svi_theme3, svi_theme4, nrow=2,ncol=2)

svi_total <- ggplot(vulnIndex) +
  geom_sf(data = st_union(vulnIndex))+
  geom_sf(aes(fill = q5(RPL_THEMES)),lwd = 0) +
  scale_fill_manual(values = palette5,
                    labels = qBr(vulnIndex %>% drop_na(RPL_THEMES), "RPL_THEMES", rnd=FALSE),
                    name = "Percentile") +
  labs(title = "Social Vulnerability Index Composite", subtitle = "By census tract, 208 CDC Social Vulnerability Index") +
  mapTheme() + 
  theme(plot.title = element_text(size=16))

svi_total
```

Although the CVI dataset includes population information for each tract, we want to be able to allocate one kit per household. We get household data from the American Community Survey and join it with our social vulnerability index information.

```{r getHousingUnitData}
projection <- "EPSG:6423"
census_api_key("e59695f18b5f5959947fd9098feba458ca285cc5", install=TRUE, overwrite=TRUE)

housingUnitsByTract <- get_acs(geography = "tract", variables = c("B07013_002E"), 
            year=2018, state='CA', county=c('Los Angeles'), geometry=T, output="wide") %>%
        st_transform(projection) %>%
        rename(HousingUnits = "B07013_002E") %>%
        dplyr::select(-starts_with("B"), -NAME)  %>%
  filter(GEOID != '06037599100') %>%
  filter(GEOID != '06037599000') %>%
  rename(FIPS='GEOID') %>%
  st_drop_geometry()

vulnIndex <- vulnIndex %>% dplyr::left_join(housingUnitsByTract, left=TRUE)
```

We combine the Social Vulnerability Index with our fire risk scores for each tract.
```{r combineScores}
fireProbabilities <- read.csv("fireProb_tracts_nogeom.csv") %>%
    rename(FIPS='GEOID') %>%
    mutate(FIPS=paste('0',as.character(FIPS),sep="")) %>%
    rename(FireProb='Probs') %>%
    mutate(FireProbNormalized = (FireProb)/(max(fireProbabilities$FireProb)))

finalDataSet <- vulnIndex %>% dplyr::left_join(fireProbabilities, left=TRUE)

write.csv(finalDataSet,"finalDataSet-forShiny.csv")
```

Finally, we create a function that can be used to output a prioritized list of census tracts. The inputs for the function are:
1. Total allocated budget (default: $250,000)
2. Cost of the kit (default: $20)
3. Percentage of households in each tract to distribute a kit (default: 100%)
4. Amount of weight to give to fire risk score, vs. vulnerability index (default: 50%)

The function returns a data set of all the tracts with a column added to indicate whether or not they should receive kits.

```{r finalOutput}

addComma <- function(num){ format(num, big.mark=",")}

getPrioritizedCensusTracts <- function(budget = 250000, costOfKit = 20, pctOfTract = 1.0, weight = 0.5){

  d <- finalDataSet %>%
    mutate(isReceivingKits = 0) %>%
    mutate(totalKitsToSend = 0) %>%
    mutate(priorityRanking = FireProbNormalized*weight + RPL_THEMES*(1-weight)) %>%
    arrange(desc(priorityRanking))

   numOfKits <- (budget / costOfKit)
  
  budgetRemaining <- budget
  tract.i <- 1
  totalHousingUnits <- 0
  
  while(budgetRemaining > costOfKit) {
      housingUnits <- floor(d[tract.i,]$HousingUnits * pctOfTract)
      if (housingUnits == 0) { tract.i <- tract.i+1; next; }
      costForTract <- housingUnits*costOfKit
   #   print(paste("Tract #",d[tract.i,]$FIPS, " is priority #", tract.i, " and has ", addComma(housingUnits), " housing units, Cost of kits: $",addComma(costForTract), sep=""))
      if(costForTract <= budgetRemaining-costForTract) {
  #      print(paste("Budget remaining: $", addComma(budgetRemaining),sep=""))
        totalHousingUnits <- totalHousingUnits + housingUnits
        kitsSent <- housingUnits
      } else {
        possibleHousingUnits <- floor(budgetRemaining/costOfKit)
        totalHousingUnits <- totalHousingUnits + possibleHousingUnits
 #       print(paste("Cost for whole tract exceeds remaining budget, partial distribution to",addComma(floor(possibleHousingUnits))," housing units possible"))
        kitsSent <- possibleHousingUnits
      }
      budgetRemaining <- budgetRemaining - costForTract
      d[tract.i,]$isReceivingKits <- 1
      d[tract.i,]$totalKitsToSend <- kitsSent
      tract.i <- tract.i + 1  
  }
#  print(paste(addComma(totalHousingUnits),"housing units in", tract.i, "LA County tracts can be served by investing $",addComma(budget),"in the emergency kit allocation program (not including overhead costs)"))
  attr(d, "budget") <- budget
  attr(d, "costOfKit") <- costOfKit
  attr(d, "pctOfTract") <- pctOfTract
  attr(d, "weight") <- weight
  return(d)
}

```

This function uses the dataframe from getPriotizedCensusTracts() to generate a map of the tracts that can be served.
```{r plot}
getServedTractsPlot <- function(df, ttl, st){
  allocationMap <- ggplot(df) +
    geom_sf(data = st_union(df))+
    geom_sf(aes(fill = isReceivingKits),lwd = 0) +
    labs(subtitle = st, title = ttl) +
    theme(plot.title = element_text(size=14)) +
    theme(plot.subtitle = element_text(size=10)) +
    theme(legend.position = "none")
  
  allocationMap
}
```


We are now able to see exactly which tracts are served. Here are a few examples where we're varying the budget and then the percentage of households in a tract that we send a kit.
```{r demoFinalAlgorithm}

example1 <- getPrioritizedCensusTracts(budget = 250000, costOfKit = 20)
example2 <- getPrioritizedCensusTracts(budget = 2500000, costOfKit = 20)
example3 <- getPrioritizedCensusTracts(budget = 2500000, costOfKit = 20, pctOfTract = 0.5)
example4 <- getPrioritizedCensusTracts(budget = 2500000, costOfKit = 20, pctOfTract = 0.5, weight=0)
example5 <- getPrioritizedCensusTracts(budget = 2500000, costOfKit = 20, pctOfTract = 0.5, weight=1)

example1.plot <- getServedTractsPlot(example1, "Tracts served (ex. 1)", "$250k and $20 kits")
example2.plot <- getServedTractsPlot(example2, "Tracts served (ex. 2)","Increased budget to $2.5m")
example3.plot <- getServedTractsPlot(example3, "Tracts served (ex. 3)","Sending kits to only 50% of households increases amount of served tracts")

grid.arrange(example1.plot, example2.plot, example3.plot, nrow=2)
```

We can also adjust the weights to see how different tracts would be served if we ONLY prioritized based off the vulnerability index or ONLY prioritized based off of the probability of a fire occuring.
```{r demoFinalAlgopt2}
example4.plot <- getServedTractsPlot(example4, "Tracts served (ex. 4)","Only prioritizing on vulnerability index")
example5.plot <- getServedTractsPlot(example5, "Tracts served (ex. 5)","Only prioritizing on fire probability")

grid.arrange(example4.plot, example5.plot, nrow=1)
```
